#!/usr/bin/env php
<?php
$filter = $path = null;
$onlydirs = $onlyfiles = false;

// Decode the command line arguments
$opts = getopt('hmrcnzfdvxb:a:', array('help'));

// Parse the path component from the command line too
$extras = array();
foreach(array_slice($argv, 1) as $option) {
	if($option[0] != '-')
		$extras[] = $option;
}

// Decode the path name from extra short-hand number components
$digits = array_filter($extras, 'ctype_digit');
if(count($digits) + 1 == count($extras)) {
	list($path) = array_diff($extras, $digits);
}

// Support shorthand syntax:
// 'lsat 5' for 'lsat -xfb5'
// 'lsat 5 2' for 'lsat -xvfb5a2'
if(count($digits) > 0 && !file_exists($digits[0]) && !isset($opts['a']) && !isset($opts['b'])) {
	switch(count($digits)) {
		case 2:
			$opts['a'] = $digits[1];
		case 1:
			$opts['b'] = $digits[0];
	}
	
	$opts += array('x' => '', 'f' => '');
}

if(isset($opts['help']) || isset($opts['h'])) {
	echo "\n";
	echo "lsat: ls at specified time\n";
	echo "by Viper-7 <viper7@viper-7.com> for PHP 5.3+\n";
	echo "\n";
	echo "Recursively lists files and folders which have status change times within a specified window\n";
	echo "\n";
	echo "\n";
	echo "Usage: lsat [-mrcnzfdvxh] [-bN] [-aN] <path>\n";
	echo "\n";
	echo "-m  \t\tFilter by last modified time (default)\n";
	echo "-r  \t\tFilter by last accessed time\n";
	echo "-c  \t\tFilter by inode change time\n";
	echo "-n  \t\tDon't sort the results\n";
	echo "-z  \t\tReverse sorting order\n";
	echo "-f  \t\tFilter to show files only\n";
	echo "-d  \t\tFilter to show folders only\n";
	echo "-v  \t\tBe verbose (display progress)\n";
	echo "-x  \t\tAttempt to exclude valid backups\n";
	echo "-bN \t\tFilter starting from N days ago (default 1)\n";
	echo "-aN \t\tFilter from N days after the starting point (default unlimited)\n";
	echo "-h  \t\tShow this help\n";
	echo "\n";
	echo "Short-hand syntax:\n";
	echo "\n";
	echo "lsat 5    \tEquivalent to lsat -xfb5\n";
	echo "lsat 5 2  \tEquivalent to lsat -xfb5a2\n";
	echo "\n";
	die();
}

if(isset($opts['v']))
	echo "Working...";

try {
	$folder = new FolderHistory($path);
} catch(Exception $e) {
	if(isset($opts['v']))
		echo "\r";

	echo $e->getMessage() . "\n";
	exit(1);
}

// Set filter mode
foreach(str_split('mrc') as $c) {
	if(isset($opts[$c])) {
		$folder->setType($c);
	}
}

// Generate timestamp for days ago filter
if(isset($opts['b'])) {
	$ts = strtotime("-{$opts['b']} days");
} else {
	$ts = time() - 86400;
}

// Generate timestamp for days since filter
if(isset($opts['a'])) {
	$filter = strtotime("+{$opts['a']} days", $ts);
}

// Sort if required
if(isset($opts['n']))
	$folder->setSort(null);

if(isset($opts['v'])) {
	$folder->setScanCallback(function($path) {
		if(substr($path, 0, 2) == './') $path = substr($path, 2);
		$path = preg_replace('/[^a-zA-Z0-9_\.\/-]+/', '', $path);
		if(strlen($path) > 71) $path = substr($path,0,68) . '...';
		echo str_pad("\rScanning {$path}", 80, ' ', STR_PAD_LEFT);
	});
}
	
// Fetch the file list
$files = $folder->listAt($ts);

// If no files were found, clear the output and end
if(!$files) {
	if(isset($opts['v']))
		echo "\r" . str_repeat(' ', 90) . "\r";
	
	die();
}

// Filter to files
if(isset($opts['f']))
	$onlyfiles = true;

// Filter to folders
if(isset($opts['d']))
	$onlydirs = true;

// Reverse array if requested
if(isset($opts['z']))
	$files = array_reverse($files);

// Scan path lengths for column spacing
$maxlen = max(array_map('strlen', array_keys($files)));

// Put the cursor back to the start of the line for our actual output
if(isset($opts['v']))
	echo "\r";

foreach($files as $file => $ts) {
	$rfile = trim($file);
	
	// Exclude files matching */backups/*.[gz|zip]
	if(isset($opts['x'])) {
		if(preg_match('/backups\/.*?\.(?:gz|zip|sql)|backups$|logs\/.*?\.log/i', $rfile))
			continue;
	}
	
	// Pad the filename out to the max width for the column
	$file = str_pad(preg_replace('/^\.\//','',$file), $maxlen, ' ', STR_PAD_RIGHT);
	
	if(is_dir($rfile))
		// Directory flag
		$size = str_pad('', 12, ' ', STR_PAD_LEFT);
	else
		// File size in kilobytes
		$size = str_pad(number_format(filesize($rfile)/1024, 1) . ' kb', 12, ' ', STR_PAD_LEFT);
	
	// Format the stat timestamp
	$stat = date('d-m-Y h:i:s', $ts);
	
	$perms = getperms($rfile);
	
	// If the file should be shown, show it!
	if((!$onlydirs || is_dir($rfile)) &&
	   (!$onlyfiles || !is_dir($rfile)) &&
	   (!$filter || $ts < $filter)) {
		echo "{$file}\t{$perms}\t{$size}\t{$stat}\n";
	}
}

class FolderHistory {
	protected $path = '.';
	protected $type = 'm';	 // ['m', 'r', 'c']
	protected $sort = 'asc'; // ['asc', 'desc']
	protected $scanCallback;
	
	const FILE_MODIFIED = 'm';
	const FILE_ACCESSED = 'r';
	const FILE_CREATED = 'c';
	
	public function __construct($path = null) {
		if($path) {
			// Test we can really resolve the path first
			$rpath = realpath($path);
			
			if(!$rpath)
				throw new Exception('Invalid path: ' . $path);
			
			$this->path = $path;
		}
	}
	
	/**
	* Set the filter mode. Accepts a FolderHistory::FILE_ contant
	**/
	public function setType($type) {
		$this->type = $type;
	}
	
	/**
	* Set the sorting mode. Accept asc, desc or null.
	**/
	public function setSort($sort) {
		$this->sort = $sort;
	}
	
	/**
	* Set a callback for the scanner to invoke as it passes over the structure
	**/
	public function setScanCallback($callable) {
		$this->scanCallback = $callable;
	}
	
	public function listAt($ts) {
		$files = array();
		
		// Iterate the path structure and collect matching files
		foreach(new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this->path, FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::SKIP_DOTS), RecursiveIteratorIterator::SELF_FIRST) as $file => $obj) {
			if(isset($this->scanCallback)) {
				$callable = $this->scanCallback;
				$callable($file);
			}
			
			try {
				// Filter and collapse to a path + timestamp based on the selected mode
				switch($this->type) {
					case self::FILE_MODIFIED:
						$time = $obj->getMTime();
						if($time > $ts)
							$files[$file] = $time;
						break;
					case self::FILE_ACCESSED:
						$time = $obj->getATime();
						if($time > $ts)
							$files[$file] = $time;
						break;
					case self::FILE_CREATED:
						$time = $obj->getCTime();
						if($time > $ts)
							$files[$file] = $time;
						break;
				}
			} catch (RuntimeException $e) {
				// Read error, ignore
			}
		}
		
		// Sort the results if requested
		if(strtolower($this->sort) == 'asc') {
			asort($files);
		} elseif(strtolower($this->sort) == 'desc') {
			arsort($files);
		}
		
		// Return an array of [path] => [stat timestamp]
		return $files;
	}
}

// Taken from php.net comments
function getperms($file) {
	$perms = fileperms($file);

	if (($perms & 0xC000) == 0xC000) {
		// Socket
		$info = 's';
	} elseif (($perms & 0xA000) == 0xA000) {
		// Symbolic Link
		$info = 'l';
	} elseif (($perms & 0x8000) == 0x8000) {
		// Regular
		$info = '-';
	} elseif (($perms & 0x6000) == 0x6000) {
		// Block special
		$info = 'b';
	} elseif (($perms & 0x4000) == 0x4000) {
		// Directory
		$info = 'd';
	} elseif (($perms & 0x2000) == 0x2000) {
		// Character special
		$info = 'c';
	} elseif (($perms & 0x1000) == 0x1000) {
		// FIFO pipe
		$info = 'p';
	} else {
		// Unknown
		$info = 'u';
	}

	// Owner
	$info .= (($perms & 0x0100) ? 'r' : '-');
	$info .= (($perms & 0x0080) ? 'w' : '-');
	$info .= (($perms & 0x0040) ?
				(($perms & 0x0800) ? 's' : 'x' ) :
				(($perms & 0x0800) ? 'S' : '-'));

	// Group
	$info .= (($perms & 0x0020) ? 'r' : '-');
	$info .= (($perms & 0x0010) ? 'w' : '-');
	$info .= (($perms & 0x0008) ?
				(($perms & 0x0400) ? 's' : 'x' ) :
				(($perms & 0x0400) ? 'S' : '-'));

	// World
	$info .= (($perms & 0x0004) ? 'r' : '-');
	$info .= (($perms & 0x0002) ? 'w' : '-');
	$info .= (($perms & 0x0001) ?
				(($perms & 0x0200) ? 't' : 'x' ) :
				(($perms & 0x0200) ? 'T' : '-'));
				
	return $info;
}